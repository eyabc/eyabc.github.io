깃 사용자가 가장 흔히 저지르는 6가지 실수와 대처 방법
--
## 마지막 커밋에 깜박하고 변경을 추가하지 않았을 때
1. 스테이징 할 새로운 변경 사항이 있다면 스테이징을 한다.
2. 커밋 메시지를 편집한다. ```git commit --amend ```
3. 파일만 병경하고 커밋 메시지를 수정할 필요가 없을 때.
```git commit --amend --no-edit```

### 실수 방지
* 깃에서 커밋하는 방법을 바꾸어야 한다.
수시로 작게 커밋하는 작업은 임시 분기에서 한다. 
그리고 이 과정에서 중요한 변경은 ```git commit```명령을 하는 시점까지 기다리지 말고 다른 곳에 문서로 작성한다.
그런 다음 중요한 이정표에 도달하면 임시 분기에서 ```git merge --squash``` 를 사용해서 
정규 작업 분기에 하나의 깔끔한 커밋으로 결과를 저장하고 앞서 작성한 문서를 커밋 메시지로 사용한다.

## 로컬 마스터에 변경을 커밋했을 때
```shell script
git branch new-branch   # 1
git reset HEAD~ --hard  # 2
git checkout new-branch # 3
```
1. 작업할 새 분기를 만든다
2. 주 분기를 마지막 커밋 직전으로 리셋하되, 변경사항은 new 분기에 남겨둔다.
3. 변경사항이 기다리고 있는 new 분기로 전환한다. 

여러 번 커밋한 경우에는 ```git reset HEAD~<n> --hard``` 
```<n>```는 되돌리고자 하는 커밋의 수다.
대상 커밋의 해시 ID를 알고 있다면 ```git reset 대상커밋의_해시ID``` 

### 실수 방
코드 세셔늘 시작할 때마다 무조건 새 분기를 만들어 그 분기로 전환하는 습관을 들이는 것이 좋다.

## 파일이나 디렉터리를 버렸을 때
1. ```git log``` 이나 IDE에 내장된 깃 툴로 파일이 수정되기 전의 커밋에 대한 해시 ID를 찾는다.
2. ```git checkout hash_id /path/to/file``` 
    * 문제의 커밋에서 그 파일만 체크아웃 한다. 
    * 상대경로
    * 이전 버전의 파일이 프로젝트의 스테이징 영역에 생성 된다.
3. ```git checkout HEAD~<n> -- /path/to/file```
    * n 번 커밋 전으로 되돌아 갈때
4. ```git checkout HEAD~1 -- ./src/**```
    * 파일의 전체 디렉터리를 체크아웃 하려면 파일 경로에 깃의 와일드카드 형식을 사용한다.
    * 한 커밋전으로 되돌아가서 프로젝트 루트에 있는 /src 디렉터리의 모든 파일을 복구한다.
    
## 실수로 분기를 삭제했을 때
1. ```git reflog``` 분기에 적용된 마지막 커밋을 찾는다.
2. ```git checkout -b restored-branch <hash_id>``` 해시ID를 사용해서 새 분기를 만든다.

단, 해당 분기가 이미 병합된 경우에만 복구된다. 병합되지 않은 분기를 강제로 삭제했다면 
리포지토리에서 ```git gc```를 실행하지 않았다는 전체하에 찾을 수 있는 방법이 하나 더 있다.

```git fsck --full --no-reflogs --unreachable --lost-found```
삭제된 분기를 포함해 더 이상 도달할 수 없는 객체의 모든 커밋 해시 목록이 표시된다.
목록의 맨 밑에서부터 위로 올라오며 "unreachable commit" 항목을 찾아서 그 해시ID를 새 분기로 복원해 문제의 분기인지 확인한다.
아니라면 위로 올라가며 다음 분기를 확인하는 과정을 반복해 복구 가능한 분기를 찾는다.

기본적으로 분기를 강제 삭제하지 않는다는 규칙에 따라야 한다.
강제 삭제할 경우 유의미한 항목이 아직 남아있는, 병합되지 않은 분기가 파괴되는 불상사가 곧잘 발생하기 때문이다.
분기를 습관적으로 강제 삭제하고 있다면 분기 작업 습관을 바꿔야 한다는 신호다.

## git push 로 원격 분기를 손상시켰을 때
로컬 사본에서 실수로 ```--force``` 옵션을 붙여 마스터 분기를 원격 사본으로 푸시했을 때.

리포지토리가 충분히 최근에 원격 리포지토리와 동기화됐다면 원격 리포지토리 분기의 사본을 사용해서 해결할 수 있다. 
다시 동기화해야 하는 분기로 전환해서 다음 명령을 실행한다. 
// ... 이해가 안되서 생략

## 공개 리포지토리에 비공개 정보를 커밋해버렸을 때
BFG Repo-Cleaner 툴 사용

* 깃에서 특정 와일드카드와 일치하거나 특정 텍스트가 포함된 모든 파일 제거
* 텍스트를 목록으로 정리한 파일 하나를 만들어 전달할 수도 있다.

```git filter-branch``` 사용과정을 자동화 한 것임.
복잡한 과정인 만큼 수작업에서 실수가 있을 수 있다.

다른 곳에서 동기화해야 하는 로컬 분기의 데이터를 삭제하는 경우 강제푸시 외에는 달리 동기화할 방법이 없다.
전체 커밋 트리를 다시 써야하므로 사실상 원격에 완전히 새로운 히스토리를 쓰는 것이다. 
변경 이후 다른 모든 사람의 리포지토리는 더 이상 유효하지 않으므로 이들도 다시 작성된 리포지토리의 사본을 가져오도록 해야한다.



Reference
--
* http://www.itworld.co.kr/news/142318#csidx141596ceb4fa221a7af7cdd6402973f