MVVM 시스템
"모델-뷰-뷰모델" 의 약자

mvc들 

![image](https://user-images.githubusercontent.com/31977543/111023309-a14b9280-841b-11eb-9dcc-843574d06234.png)

(controller 는 view 와 model 을 알고있다.)
화살표는 알고 있다 관계

view 가 모델을 알고있다는 것은 큰 문제를 일으킨다.
모델은 비즈니스에 관계된 것이라, 갑자기 생겨날 수도 있고 변경될 수도 있다.
그리고 view 는 사용자의 인터렉션하는 방법을 변경할 수 도 있다.

뷰와 모델은 변화하는 특징(변경이유)에 대해서 상관이 없는데, 의존성이 있다는 것이 문제다.

따라서, mvc 는 주로 서버에서 쓴다.
서버에서는 view -> model 관계가 없다.

클라이언트는 mvc 는 잘 안쓰게 되었다.

제왕적 controller mvc 모델

![image](https://user-images.githubusercontent.com/31977543/111023322-b1637200-841b-11eb-9df3-41c5f09e1a9d.png)
view 가 대신에 controller 를 알게 되었다. 
컨트롤러가 모두 알게된 구조인데 
문제는
실질적으로 뷰가 모델의존이 없어졌지만
컨트롤러가 뷰와 모델의 변화를 반영해 주어야 한다. 
컨트롤의 유지보수가 힘들어진다.

이런 의존성들을 해결할 수 있는 방법이 mvc 자체에서는 없다.

mvp model view presenter
![image](https://user-images.githubusercontent.com/31977543/111023342-dc4dc600-841b-11eb-9ce9-d9ed6e8f4048.png)
많이 채용되었다.
비주얼 베이직, MFC, 안드로이드뷰 가 이 모델을 쓴다.

뷰에 대한 모델의 의존성이 완전히 제거됌 

뷰가 그림을 그리는 재량권은 모두 잃어버리고 Presenter 가 getter setter 를 통해서 통제를 바꿔줌
뷰에 많은 getter setter 를 만들어야 한다는 단점

mvvm 은 
아예 뷰모델이 뷰를 모르게 하는 것에 있다. 

binder 라는 것이 필요하다.
그리고 mvvm 을 이해하는 첫걸음은 viewModel 에 있다. 이것은 순수한 view 이다. 이것은 그림 그리는 view 가 아닌
인메모리 개체로서의 순수한 데이터로서의 뷰 이다.
뷰를 대신할 객체이다.
노드에서는 dom 이 없다. 대신 노드에서 view 모델을 갱신할 수 있다.
뷰모델에 맞게 그림이 그려져야 할 것이다. 

바인더가 뷰모델의 변화를 감지해 뷰를 변경해 주길 바라거나, 
뷰의 변화가 생기면 바인더를 따라서 뷰의 모델을 갱신해주는 것을 원한다. 

자동으로 해주는 바인더가 있어야 MVVM 이 성립한다. 

뷰와 뷰모델사이의 의존성을 바인더가 다 아는 것으로 둘 사이의 의존성을 없애 버렸다. 

여기서 핵심은 뷰 모델은 뷰를 모른 다는 것

![image](https://user-images.githubusercontent.com/31977543/111023682-bcb79d00-841d-11eb-8c9e-bd7a70d48903.png)
단방향 observation 

binder 가 observe 하는 대상은 옵션이다. 


observer 가 어려우니 약간 다른 모델을 사용할 것인데, 
![image](https://user-images.githubusercontent.com/31977543/111023685-c7723200-841d-11eb-9baf-e2bb8409fbd0.png)
뷰 모델이 바인더를 알게 해서 직접 상태가 바뀜을 call 해 준다.

옵저버보다 수동으로 call 을 하는 것이 유리한 경우도 있다.
옵저버는 뷰모델이 10개 바뀌면 10번 갱신이 되지만
call 은 수동으로 한번에 갱신할 수도 있다.


## TypeCheck


자바스크립트는 타입언어가 아니기 때문에 런타임에 throw 를 던지지 않으면 오류가 전파된다.
런타임밖에 없는 언어의 가장 좋은 전략은 에러를 감지하는 즉시 throw 를 던져야 디버깅할 수 있다. 
```javascript
const type = (target, type) => {
  // string, number, boolean 은 객체가 아니기 때문에 타입비교를 할 때 typeof 를 사용해야 하고,
  // typeof 의 결과 타입이 문자열로 반환된다.
  if (typeof type == 'string') {
    if (typeof target != type) 
      throw `invaild type ${target}: ${type}`;

  // 객체 비교할 때
  } else if (!(target instanceof type))   
      throw `invaild type ${target}: ${type}`;

  return target;
};

type(12, 'number');
type('abc', 'string');
type([1, 2, 3], Array);
type(new Set, Set);
type(document.body, HTMLElement);
```

=== 이 아닌 == 을 사용하는 이유는, === 는 형일치 검사를 하기 때문에, == 검사를 해서 두번 작동을 하기 때문에 느린다.
type 은 javascript 의 특징을 잘 살린 함수이다. 

함수의 인자를 의식할 떄 왼쪽에서 오른쪽으로 스코프가 하나씩 만들어지면서 처리된다. 
따라서 2번째 인자는 1번째 인자의 값을 알고 있다.
```javascript
// 첫번째 인자가 Array 가 아니면, 즉시 throw 가 일어난다. 
const test = (arr, _ = type(arr, Array)) => {
  console.log(arr);
};

test([1, 2, 3]);
test(123);

const test2 = (a, b, c, _0 = type(a, 'string'), _1 = type(b, 'number'), _2 = type(c, 'boolean')) => {
  console.log(a, b, c);
};
test2('abc', 123, true);
```

## view book & bind
![image](https://user-images.githubusercontent.com/31977543/111024565-cdb6dd00-8422-11eb-99b6-cf1a420040e3.png)

## Role Design

vue 와 angular 는 바인더가 존재하는 view 를 스캔한다. 
- 모델과 뷰를 완전히 분리해서 관리하기 쉽다. 

아니면
처음부터 데이터와 연결되어있는 뷰를 만들어서 뷰를 꽂게 하는? 컴포넌트 방식이 있다. 
리액트는 컴포넌트에서 스테이트를 소유하고 있다. 
- 모델과 뷰를 같이 관리해야 된다. 

각각 장단점이 잇다. 

HTMLElement 는 자주**변하기** 때문에 Binder 에서 Scanner 를 분리하였다. (역할의 분리)

변화율에 따라서 역할을 분리한다. 코드를 바꾸는 이유가 똑같냐 다르냐에 따라 분리한다.
바인더는 뷰모델을 이용해서 뷰를 그릴떄만 로직이 바뀌면 된다.
스캐너는 HTML 을 해석하는 것이 다르면 바뀐다.
변화율은 시간에 따른 변화율이 아니라 원인에 따른 번화율이다. 

객체가 바뀌는 이유를 하나로 만들자 SRP

![image](https://user-images.githubusercontent.com/31977543/111025033-2be4bf80-8425-11eb-908c-5b38b4628bf4.png)

scanner 로 인해서 binder 와 html 의 관계를 끊었다. 

hook 하나 하나를 binderItem 으로 만든다.
![image](https://user-images.githubusercontent.com/31977543/111024700-89780c80-8423-11eb-8b41-5349d5c169a2.png)
![image](https://user-images.githubusercontent.com/31977543/111025101-81b96780-8425-11eb-962e-19de651552d9.png)

## ViewModel
순수한 인메모리 객체이기 때문에 만들기 제일 쉽다.
그리고 단위테스트도 쉬워진다. dom 을 테스트하기는 어렵지만 viewmodel 을 테스트 하기는 쉽다. 
```javascript
constViewModel = class {
  static #private = Symbol();

  staticget(data) {
    returnnewViewModel(this.#private, data);
  }

  // constViewModel 는 하나의 dom 객체를 대신하는 메모리 객체기 때문에 
  // dom 을 대신할 속성들을 가진다. 
  styles = {};

  // property 와 attribute 의 차이를 dom 에서는 중요하게 본다.
  // input 같은 경우에도 property value 인가 attribute value 인가에 따라서도 다르게 작동한다 ??
  // 태그에다가 선언한것 dom 에다가는 setAttirbute, getAttribute,...
  attributes = {};
  // element.a = 3, 
  properties = {};
  events = {};

  constructor(checker, data) {
    // 1) 외부에서는 절대 첫번째 인자에 static private 을 넘길 수 없다.
    // get(data) 에서 오직 내부에서만 첫번째 속성을 #private 을 넘길 수 있다.  
    // 따라서 외부에서 생성자를 호출할 수 없다. 
    if (checker != ViewModel.#private) throw'useViewModel.get()!';
    Object.entries(data).forEach(([k, v]) => {
      switch (k) {
        case'styles':
          this.styles = v;
          break;
        case'attributes':
          this.attributes = v;
          break;
        case'properties':
          this.properties = v;
          break;
        case'events':
          this.events = v;
          break;
        default:
          this[k] = v;
      }
    });
    // 값은 변화할 수 있지만 더이상 키는 추가할 수 없게 함. 
    Object.seal(this);
  }
};
```

어떠한 종류의 뷰라고 할지라도, 그리는 로직을 binder 에게 모았다. (제어의 역전)

## Binder
```javascript
constBinderItem = class {
  el;
  viewmodel;

  constructor(el, viewmodel, _0 = type(el, HTMLElement), _1 = type(viewmodel, 'string')) {
    this.el = el;
    this.viewmodel = viewmodel;
    Object.freeze(this);  // 불변객체화
  }
};
```

```javascript
new BinderItem(section, 'wrapper');
new BinderItem(h2, 'title');
new BinderItem(section2, 'contents');
```

```html
<section id="target" data-viewmodel="wrapper">
  <h2 data-viewmodel="title"/>
  <section data-viewmodel="contents"/>
</section>
```



```javascript
const Binder = class {
  // 언제 Set 을 쓰고 언제 배열을 쓸까? 
  // 물론 Set 은 중복 방지기능이 있다. Set 은 객체의 컨테이너다. 배열은 똑같은 객체를 두번 넣을 수 있다. 
  #items = new Set;

  add(v, _ = type(v, BinderItem)) {
    this.#items.add(v);
  }

  render(viewmodel, _ = type(viewmodel, ViewModel)) {
    this.#items.forEach(item => {
      const vm = type(viewmodel[item.viewmodel], ViewModel), el = item.el;
      Object.entries(vm.styles).forEach(([k, v]) => el.style[k] = v);
      Object.entries(vm.attributes).forEach(([k, v]) => el.setAttribute(k, v));
      Object.entries(vm.properties).forEach(([k, v]) => el[k] = v);
      Object.entries(vm.events).forEach(([k, v]) => el['on' + k] = e => v.call(el, e, viewmodel)); // this 를 el 로 바인딩
    });
  }
};
```

## Scanner
```javascript
const Scanner = class {
  scan(el, _ = type(el, HTMLElement)) {
    const binder = newBinder;
    this.checkItem(binder, el);

    // dom Roop
    const stack = [el.firstElementChild];
    let target;   // 임시변수
    while (target = stack.pop()) {
      this.checkItem(binder, target);
      if (target.firstElementChild) stack.push(target.firstElementChild);
      if (target.nextElementSibling) stack.push(target.nextElementSibling);
    }
    return binder;
  }

  checkItem(binder, el) {
    const vm = el.getAttribute('data-viewmodel');
    if (vm) binder.add(newBinderItem(el, vm));
  }
};
```
