# 엄격모드 [:link:](https://beomy.tistory.com/13)
> TODO use strict는 어떻게 동작하는걸까 ?

ES5에 추가됨

읽기전에[:link:](https://overcurried.com/%EC%A0%84%EC%97%AD%20%EA%B0%9D%EC%B2%B4%EA%B0%80%20%EC%A0%84%EC%97%AD%20%EA%B0%9D%EC%B2%B4%EC%9D%B8%20%EC%9D%B4%EC%9C%A0/)
ES5 이전이라 함은, let, const도 없는 var의 시대 변수도 객체의 프로퍼티일 시절!

자바스크립트가 묵인했던 에러들의 에러 메시지 발생
- 모든 문법과 런타임 동작 검사
    - 실수를 에러로 변환
- 변수 사용 단순화


strict 모드 선언
- 스크립트 혹은 함수의 시작부분에 `'use strict'` 선언


## 객체
### 선언하지 않고 전역 변수를 만들 수 없다.
Reference Error
```javascript
testvar = 5;
```

### 읽기 전용객체(writable: false)에 쓰는 것이 불가능
TypeError
```javascript
var textObj = Object.defineProperties({}, {
    prop1: {
        value: 10,
        writable: false
    }
})
textObj.prop1 = 20;
```

### get으로 선언된 객체 수정 불가능
TypeError
```javascript
var obj2 = { get x() { return 17; } };
obj2.x = 5;
```

### extensible: false 객체 확장 불가능
TypeError
```javascript
var testObj = new Object();
Object.preventExtensions(testObj);
testObj.name = 'Bob';
```

### delete 변수, 함수, 인수 삭제
SyntaxError
```javascript
var testvar = 15;
function testFunc() {}
delete testvar;
delete testFunc;

Object.defineProperty(testObj, "testvar", {
 value: 10,
 configurable: false
});
delete testObj.testvar;
```

### 리터럴 객체는 동일한 이름의 property 를 가질 수 없다.
ES6 는 가능

SyntaxError
```javascript
var o = { p: 1, p: 2 };
```

### 함수의 동일한 매개 변수 이름 선언 불가능
SyntaxError
```javascript
function testFunc(param, param) {}
```

### 8진수 숫자 리터럴, 이스케이프 문자 사용 불가능
SynTaxError
```javascript
var testoctal = 010;
var testescape = \010;
```

### primitive values 속성 불가능
TypeError
```javascript
false.true = "";
(14).sailing = "home";
"with".you = "far away";
```

## 변수 사용의 명료화
strict 모드는 변수 이름의 Mapping 을 단순화 한다.

대부분의 컴파일러의 최적화는 변수의 Mapping 에 달려있다.

### with 사용 불가
[:link:](./문법%20사전#with.md)

Syntax Error
```javascript
var foo = { name: "foo" }; 
with (foo) { console.log(name); }
```

with 블록 안의 name 은 전역변수의 name 인지 foo 의 name 인지 모호하다.

### eval 는 주변 스코프에 새로운 변수를 추가하지 않음
[:link:](./문법%20사전.md#eval)

```javascript
var x = 17;
var evalX = eval("'use strict'; var x = 42; x")
console.log(x) // 17
console.log(evalX) // 42
```

### eval/arguments 를 변수, 함수, 매개변수의 이름으로 사용 불가능
SyntaxError
```javascript
eval = 17;
++eval;
var eval;
function x(eval) {}
var y = function eval() {}
```

### 인자값을 수정해도 arguments 의 값이 수정되지 않음
```javascript
function f (a) {
    'use strict';
    a = 42;
    return [a, arguments[0]];
}
var pair = f (17);
console.log(pair) // [42, 17]
```

### callee 미지원
TypeError
```javascript
var f = function() { return arguments.callee };
f();
```

## Securing JavaScript
보안에 강한 자바스크립트 작성

사용자가 작성한 자바스크립트의 접근을 막음

### this 값이 null 또는 undefined 면 전역 객체로 변환하지 않음
```javascript
function fun() { return this; }

console.log(fun()); // undefined
console.log(fun.call(2)); // 2
console.log(fun.apply(null)); // null
console.log(fun.call(undefined)); // undefined
console.log(fun.bind(true)());  // true
```
this 의 결과가 undefined 의 경우 window 객체로 변환하지 않고, undefined 가 그대로 보이게 됩니다.

### callee, caller 로 stack 검색 불가능
```javascript
function restricted () {
    'use strict';
    restricted.caller;  // TypeError
    restricted.arguments; // TypeError
}
function privilegedInvoker() {
    return restricted();
}
privilegedInvoker();
```

### arguments caller 미지원
```javascript
function fun(a, b) {
    'use strict';
    var v = 12;
    return arguments.caller; // TypeError
}
fun (1, 2) // doesn't expose v (or a or b)
```

## 미래의 자바스크립트 준비
### 예약어로 변수/함수 생성 불가능
implements, interface, package, private, protected, public, static, yield

### 함수 선언은 스크립트나 함수의 최상위에서 한다.
최상위에서 선언하지 않은 함수는 다른 의미를 줄 수 있음 (?)TODO
```javascript
if (true) {
    function f() {} // syntax error
    f();
}
for (var i = 0; i < 5; i++){ 
    function f2() { } // !!! syntax error f2(); 
} 
function baz(){  
    function eit() { } 
}
```
