---
title: 1. 함수형 프로그래밍 개요
---
- [인프런 함수형 프로그래밍 유인동](https://www.inflearn.com/course/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
## 성공적인 프로그래밍
- 모든 프로그래밍 패러다임은 성공적인 프로그래밍을 위해 존재한다.
- 성공적인 프로그래밍은 좋은 프로그램을 만드는 일이다.
- 좋은 프로그램은 사용성, 성능, 확장성, 기획변경에 대한 대응력이 좋다.
- 이것들을 효율적이고 생산적으로 이루는 일이 성공적인 프로그래밍이다.


## 함수형 프로그래밍 정의, 순수함수
함수형 프로그래밍은 성공적인 프로그래밍을 위해
부수효과를 미워하고 조합성을 강조하는
프로그래밍 패러다임이다.

- 부수효과를 미워한다 -> 순수함수를 만든다.
- 조합성을 강조한다 -> 모듈화 수준을 높인다.
- 순수함수로 모듈화 수준을 높이게 되면 오류를 줄이고 안정성을 높일 수 있다.
- 모듈화 수준이 높다 -> 생선성을 높인다.

함수형 프로그래밍은 애플리케이션, 함수의 구성요소, 더 나아가서 언어 자체를 함수처럼 여기도록 만들고,
이러한 함수 개념을 가장 우선순위에 놓는다.

함수형 사고방식은 문제의 해결 방법을 동사(함수) 들로 구성(조합) 하는 것

데이터(객체) 기준
```javascript
duck.moveLeft();
duck.moveRight();
```
함수 기준
```javascript
moveLeft(dog);
moveRight(duck);
```


## 순수함수
원래 있던 부분은 놔두고 새로운 값을 생성해서 리턴하는 형식으로 함수를 만든다.

### 순수함수의 조건
1. 들어오는 인자가 같으면 항상 동일한 결과를 리턴한다.
    ```javascript
    function add(a, b) {
        return a + b;
    }
    console.log(add(10, 5));
    console.log(add(10, 5));
    ```

2. 평가 시점이 중요하지 않다.
    - 서로 다른 공간이나 스레드에서 함수를 평가시켜도 항상 동일한 결과를 리턴하기 때문에 안전하고 다루기 쉽다.
    - 아닐 조건
    c 가 상수일 때는 순수함수지만, 변수일 때는 순수함수가 아닐 수 있다.
    c 변경 전후(평가 시점) 에 따라서 같은 인자더라도 다른 결과를 리턴한다.
      ```javascript
        var c = 10;
        function add2(a, b) {
            return a + b + c;
        }
        console.log(add(10, 2));
        console.log(add(10, 3));

        c = 20;
        // 결과가 달라진다.
        console.log(add(10, 2));
        console.log(add(10, 3));
    ```

3. 부수효과가 없다. 리턴값 외에는 외부와 소통하지 않는다.
    - 부수효과
        - 외부의 상태를 변경
            ```javascript
            var c = 20;
            function add3(a, b) {
                c = b;
                return a + b;
            }
            console.log(c); // 20
            console.log(add3(20, 30));
            console.log(add3(20, 30));
            console.log(c)  // 30
            ```
        - 들어온 인자의 상태를 직접 변경
            ```javascript
            var obj1 = { val: 10 };
            function add4(obj, b) {
                obj.val += b;
            }
            console.log(obj1.val); // 10
            add4(obj1, 20);
            console.log(obj1.val); // 30
            ```
    - 부수효과가 없는 함수
        ```javascript
        var obj1 = { var: 10 };
        function add5(obj, b) {
          return { val: obj.val + b }
        }
        console.log(obj1.val);    // 10
        var obj2 = add5(obj1, 20);
        console.log(obj1.val);    // 10
        console.log(obj2.val) // 20
        ```


## 일급함수
함수를 값으로 다룰 수 있다.
- 런타임에서 언제나 정의할 수 있다.
- 인자로 넘겨질 수 있다.
    ```javascript
    var f1 = function(a) { return a * a };
    console.log(f1)
    ```
- 함수를 변수에 담는다 `var f2 = add;`
- 원하는 시점에 평가할 수 있다.

```javascript
function f3(f) {
    return f();
}
f3(function() { return 10; });
f3(function() { return 20; });
```

### add_maker
함수를 리턴하는 함수
```javascript
function add_maker(a) {
    return function(b) {
        return a + b;
    }
}
var add10 = add_maker(10);
console.log(add10(20));
```
add_maker(10)을 호출하면
```javascript
return function(b) {
    return 10 + b;
}
```
라는 함수(클로저)를 리턴하게 된다.
add10 는 위에 생성된 익명함수가 되고 add10(20) 을 호출하면 20을 리턴하게 된다.


위 예제는 아래 세가지를 담고 있다.
1. 클로저
2. 일급함수
3. 순수함수
    - a 는 클로저 내부에서 사용되지만 a 의 상태를 변경하고 있지 않다.

```javascript
function f4(f1, f2, f3) {
    return f3(f1 + f2);
}
f4(
    function() { return 2; },
    function() { return 3; },
    function(a) { return a * a }
);
```
순수한 함수들을 조합하고, 평가 시점에 의존되지 않도록 하는 프로그래밍.

## 요즘 개발 이야기
|   |   |
|---|---|
| 재미, 실시간성 | 라이브방송, 실시간 댓글, 협업, 메신저|
| 독창성, 완성도 UI UX | 애니메이션, 무한 스크롤, 벽돌형태 리스트 |
| 더 많아져야하는 동시성 | 비동기 I/O, CSP, Actor, STM |
| 더 빨라야하는 반응성, 고가용성 | ELB, Auto Scaling, OTP Supervisor |
| 대용량, 정확성, 병렬성 | MapReduce, Clojure Reducers |
| 복잡도, MSA, ... | 많아지고 세밀해지는 도구들 |
* 고가용성 - 절대 죽지 않는 서비스

- 좋아지는 하드웨어 성능
- 좋아지는 컴파일러
- 함수형 프로그래밍 기술
- 좋아지는 분산/리액티브 환경
- 동시성 + 병렬성 관련 기술
- 성공적인 적용 사례

