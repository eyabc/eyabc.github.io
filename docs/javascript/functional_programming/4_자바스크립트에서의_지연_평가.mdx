---
title: 4. 자바스크립트에서의 지연 평가
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

* 지금까지 만든 함수를 포함하고 있는 [partial.js](https://marpple.github.io/partial.js/) 라는 라이브러리를 import 해야 한다.

## 지연 평가

지연 평가를 시작 시키고 유지 시키는(이어 가는) 함수
1. map
2. filter, reject

끝을 내는 함수
1. take
2. some, every, find

---

<Tabs
defaultValue={'엄격한 평가'}
values={[
  {label: '엄격한 평가', value: '엄격한 평가'},
  {label: '지연평가 적용 후', value: '지연평가 적용 후'},
]}
>

<TabItem value={'엄격한 평가'}>

앞서 함수를 모두 실행하고 리턴한 결과를 다음함수에 인자로 받아 쓰는 형태

다음은, take(5) 를 함에도 불구하고, map 과 filter를 각각 100번씩 반복한다.
```javascript
let mi = 0;
let fi = 0;

_.go(
  _.range(100),
    _.map(function(val) {
    ++mi;
    return val * val;
  }),
  _.filter(function(val) {
    ++fi;
    return val % 2;
  }),
  _.take(5),
  console.log
);  // [1, 9, 25, 49, 81]

console.log(mi, fi);  // 100 100
```



</TabItem>

<TabItem value={'지연평가 적용 후'}>

1. 배열 순서대로 하나씩 map 으로 나온 결과가 filter 에서
    - false 로 평가되면 두번째 map을 실행한다.
    - true 로 평가되면 take 에 담기게 된다.
2. (1) 이 반복적으로 실행되고 take 에 원하는 만큼 담아질 때 함수의 실행을 종료한다.


partial.js 의 지연평가를 적용하는 방법은 다음과 같다.
```javascript {6,10,14,18}
let mi = 0;
let fi = 0;

_.go(
  _.range(100),
  L.map(function(val) {
    ++mi;
    return val * val;
  }),
  L.filter(function(val) {
    ++fi;
    return val % 2;
  }),
  L.take(5),
  console.log
);  // [1, 9, 25, 49, 81]

console.log(mi, fi);  // 10 10, 지연평가 적용 후 loop 가 100 에서 10 으로 감소함
```

지연평가에 적용된 함수형 프로그래밍의 최적화 방법
- **순수함수** 는 어느시점에 평가순서나 시점을 다르게 평가를 해도 같은 결과가 나온다.

```javascript title="_.some, true 를 만날 때 까지 반복한다."
_.go(
  _.range(100),
  L.map(function(val) {
    ++mi;
    return val * val;
  }),
  L.filter(function(val) {
    ++fi;
    return val % 2;
  }),
  L.some(function(val) {
    return val > 100;
  }),
  console.log
);
console.log(mi, fi);  // 12, 12
```

</TabItem>

</Tabs>

## 함수형 자바스크립트 요약
1. 함수룰 되도록 **작게** 만들기
2. **다형성** 높은 함수 만들기 (보조함수와의 조합을 통해)
3. **상태**를 변경하지 않거나 **정확히** 다루어 **부수 효과를 최소화**하기
  - 상태를 변경할 함수와 변경하지 않을 함수를 명확히 한다.
  - 부수효과가 없을 수는 없다.
  - 부수효과는 해당하는 프로그래밍의 최종 목적에서 발생시키는 행위로 최소화 한다.
  - 최종 목적까지 도달 과정에서는 부수효과를 없게 한다.
4. 동일한 인자를 받으면 항상 동일한 결과를 리턴하는 **순수함수** 만들기
5. 복잡한 객체 하나를 인자로 사용하기보다 되도록 **일반적인 값** 여러 개를 **인자**로 사용하기
6. 큰 **로직**을 **고차 함수**로 만들고 세부 로직을 **보조 함수**로 완성학.
7. 어느곳에서든 **바로 혹은 미뤄서 실행** 할수있도록 일반 함수이자 순수함수로 선언하기
8. 모델이나 컬렉션 등의 커스텀 객체보다는 **기본 객체**를 이용하기
9. 로직의 흐름을 최대한 **단방향으로 흐르게** 하기
10. 작은 함수를 **조합**하여 큰 함수 만들기.

## 데이터 흐름 프로그래밍
```javascript
_go(null,
  _map(function(user) {
    return user.name;
  }),
  _map(function(name) {
    return name.toLowerCase();
  }),
  console.log)
);
```

## 데이터 흐름 프로그래밍의 중요성
1. 함수형 프로그래밍은 Clojure 와 Elixir 등.. 다른 언어를 사용하더라도 적용되는 프로그래밍 패러다임이다.
2. 지연평가 + 병렬성 + 동시성
  - 순수함수가 있기에 가능한 함수형프로그래밍의 아이디어
### 지연평가
- 어느 시점에 평가해도 동일한 결과가 나오는 순수함수의 조합으로 사용하기 때문에 가능하다.
- 동시에 다른 쓰레드에서 평가해도 상관이 없기 때문에 동시성과 병렬성 상황에서 유리하다.

### pmap
클로저에 있는 함수로, pmap 은 각각의 맵을 다른 쓰레드에서 병렬적으로 실행한다.
![image](https://user-images.githubusercontent.com/31977543/131512397-37bec6c1-a7bd-429e-884a-012a473a7c42.png)

### pcalls
클로저에 있는 함수로, 함수들을 별로의 쓰레드에서 동작시키고 결과를 만든다.
![image](https://user-images.githubusercontent.com/31977543/131512912-70d6c956-c921-4b7b-92ac-30f22453e833.png)

### reduce
reduce 는 다음과 같이 평가를 한다.

![image](https://user-images.githubusercontent.com/31977543/131513149-afe4f4e0-59a6-4c3e-a1fd-eef049f53c90.png)

reduce 의 순서를 바꿔서 평가를 해도 동일한 결과를 얻을 수 있다.

![image](https://user-images.githubusercontent.com/31977543/131513331-d60abb57-373c-4582-aaca-95792ed10d0d.png)

![image](https://user-images.githubusercontent.com/31977543/131513550-cc74219d-0ba5-47ac-9675-dd4de7ac5ca0.png)

### 비동기 IO NodeJS
`_.go` 함수는 함수를 받아서 원하는 시점에 평가할 수 있게 해준다.

프로미스 객체를 중간에 파이프라인으로 리턴받게 되면 내부적으로 결과를 기다렸다가 다음함수를 실행할 수 있게 해줘서 Promise 와 동일한 표현이 가능하다.

```javascript
square(10)
.then(square)
.then(square)
.then(square)
.then(square)
.then(console.log)
```

```javascript
_.go(square(10)
    square,
    square,
    square,
    console.log
)
```

만약 `square` 함수가 Promise 가 아닌 일반 함수로 변경되었을 때,
- `_.go` 는 에러가 나지 않음
- 프로미스 체이닝은 에러 발생


